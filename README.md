# Encrypted Morse Messenger

A tiny **offline-friendly** single-page web app that encrypts messages with
AES-256-GCM, converts the ciphertext to Morse code, and lets you play or
download it as a WAV audio file. Recipients can upload the WAV, decode it back
to Morse, and decrypt the message — all in the browser, with no server
involved.

> No servers. No accounts. No data leaves your browser. Works 100% offline.

---

## Live Demo

✅ https://systemslibrarian.github.io/dad-mode-morse/

---

## Full workflow

```
Sender
  1. Type message + password (and optional **Signal Key**) → click Transmit
  2. App encrypts with AES-256-GCM (random salt + IV every time)
  3. Ciphertext hex → Morse code → audio beeps
  4. Click "Download Morse WAV" → share the .wav file

Recipient
  1. Upload the .wav file
  2. Click "Decode WAV → Morse" → Morse string auto-populates
  3. Enter the shared password (and **Signal Key**, if used) → click Decrypt → read the message
```

The WAV file is **safe to share publicly** — without the correct password it is
unreadable. The audio sounds like random beeps to anyone without the password.

---

## Step-by-step

### Sender — Encrypt & transmit

1. Enter your **message** and a strong **password** (**14+ characters recommended**, or a 4–5 word passphrase).
2. Click **Transmit**
3. The app encrypts your message and generates the Morse string
4. Choose one or more ways to share:
   - **Copy Morse** — share the Morse text string directly
   - **Play Morse Sound** — listen to the beeps (pause/resume supported)
   - **Download Morse WAV** — save a `.wav` file to share

> The **Signal** slider adds radio-style noise to the WAV for realism (lower
> signal = more noise). Keep it at 100% for reliable decoding by the recipient.

### Recipient — Decode & decrypt

**Received a WAV file:**
1. Upload it using the file picker in the decrypt section
2. Click **Decode WAV → Morse** — the Morse string auto-fills
3. Enter the shared password
4. Click **Decrypt** → the original message appears

**Received a Morse string:**
1. Paste it into the *"Paste received Morse code here"* field
2. Enter the shared password
3. Click **Decrypt**

---

## Cryptography

| Property | Value |
|---|---|
| Algorithm | AES-256-GCM (authenticated encryption with associated data) |
| Key derivation | PBKDF2-HMAC-SHA256 (calibrated per device; iterations stored in payload) |
| Optional "Signal Key" (pepper) | User-supplied extra secret phrase (not stored/transmitted) |
| KDF iterations | 150,000 |
| Salt | 16 bytes, cryptographically random **per message** |
| IV / nonce | 12 bytes, cryptographically random **per message** |
| Payload layout | **DMM1 v2**: `"DMM1" ‖ ver ‖ kdf_id ‖ flags ‖ iters ‖ salt ‖ iv ‖ ciphertext+tag` (AAD-authenticated) |
| Backwards compatibility | Can still decrypt legacy v1 payloads (`salt ‖ iv ‖ ciphertext`) |
| Encoding | binary payload → lowercase hex → Morse (hex digits `0–9`, `A–F`) |
| Crypto engine | Browser Web Crypto API (`crypto.subtle`) — zero third-party libs |

### Security properties

- **Confidentiality** — AES-256 is computationally infeasible to brute-force
- **Integrity / authenticity** — GCM authentication tag detects any tampering;
  a wrong password or a modified byte always causes decryption to **throw**,
  never silently returning garbage
- **Semantic security** — random salt + random IV means the same plaintext +
  password produces a different ciphertext every single time
- **No key reuse** — PBKDF2 derives the AES key from password + salt; the raw
  password is never stored or transmitted
- **Fully auditable** — the entire application is in one file (`index.html`);
  inspect it at any time

---


---

## Signal Key ("pepper")

Dad Mode Morse supports an **optional** second shared secret called the **Signal Key** (a.k.a. *pepper*).

- If the sender uses a Signal Key, the recipient **must** enter the same Signal Key to decrypt.
- The Signal Key is **not stored** in the WAV payload and is **never transmitted**.
- This greatly increases resistance to offline guessing attacks if the WAV is intercepted.

Think of it like a call sign / authentication phrase — fitting for a Navy Morse heritage.

## WAV decoder

The **Decode WAV → Morse** button analyses audio entirely in the browser:

1. Decode audio to PCM (any sample rate, mono or stereo)
2. Compute RMS energy in 5 ms frames
3. Threshold at 15% of the 95th-percentile energy → binary tone-on/off
4. Run-length encode the signal
5. Estimate the dot (unit) length by finding the largest relative gap in sorted
   on-durations — correctly handles all-dots, all-dashes, and mixed inputs
6. Classify each run as `.` `-` letter-gap or word-gap `/`
7. Output the Morse string into the decrypt field

Works reliably on WAV files generated by this app at 100% signal quality.
Heavily degraded (noisy) audio may introduce symbol errors.

---

## Files

| File | Purpose |
|---|---|
| `index.html` | The entire app — HTML, CSS, and JS in one self-contained file |
| `turtle.png` | Header image and video poster |
| `turtle.mp4` | Transmit animation (plays while sending) |
| `test_crypto.mjs` | Encryption/decryption test suite (Node.js, Web Crypto API) |
| `test_decode.py` | Morse WAV decode test suite (Python 3, stdlib only) |

> GitHub Pages is case-sensitive — filenames must match exactly: `turtle.png`, `turtle.mp4`.

---


---

## Offline integrity (recommended)

For maximum trust, download the repo (or just `index.html`) and run it locally (no network).

Tip: publish a SHA-256 hash for each release so users can verify `index.html` hasn’t been tampered with.

Current `index.html` SHA-256 (this commit): `b67a55df3079e7a5de276174a2d9b9fb011e07e1fa6bb46f2a289a17fdf8b5f7`

## Run locally

### Option A: open the file directly

1. Clone or download the repo
2. Double-click `index.html`

### Option B: local dev server (recommended)

Some browsers restrict the clipboard API and AudioContext in `file://` mode.

**Python:**
```bash
python3 -m http.server 8080
# open http://localhost:8080
```

**Node.js:**
```bash
npx serve .
# open http://localhost:3000
```

---

## Tests

### Encryption tests — `test_crypto.mjs`

Uses the **exact same Web Crypto API** as the browser (built into Node.js 15+).
No dependencies required.

```bash
node test_crypto.mjs
```

| # | What is tested |
|---|---|
| 1 | DMM1 v2 encrypt + decrypt round-trip (correct password recovers plaintext) |
| 2 | Wrong password is rejected (AES-GCM auth tag + AAD) |
| 3 | Random salt + IV — same message/password produces different ciphertext every time |
| 4 | Hex ↔ Morse conversion is perfectly lossless (all 16 hex digits covered) |
| 5 | Full pipeline: encrypt → hex → Morse → hex → decrypt |
| 6 | Unicode / emoji / CJK characters survive the full round-trip correctly |
| 7 | Empty string is handled without errors |
| 8 | Long message (1000 chars) round-trips correctly |
| 9 | Tampered ciphertext is rejected (GCM + AAD integrity check) |
| 10 | DMM1 v2 payload binary layout — 40-byte header + ciphertext + tag |
| 11 | Morse output contains only valid hex Morse symbols |
| 12 | All 16 hex characters map to unique, non-overlapping Morse codes |
| 13 | Signal Key (pepper) encrypt + decrypt round-trip |
| 14 | Pepper used → decrypt without pepper throws |
| 15 | Wrong pepper → decrypt fails |
| 16 | No pepper → FLAG_PEPPER bit is 0 |
| 17 | With pepper → FLAG_PEPPER bit is 1 |
| 18 | Tampered header (AAD) is rejected |
| 19 | Legacy v1 payload decrypts correctly (backward compat) |
| 20 | PBKDF2 iterations stored in header match encrypt params |
| 21 | `concatPwPepper` combines password + pepper with NUL separator |
| 22 | HKDF key separation: different info → different keys |
| 23 | `isDmm1` rejects invalid inputs |
| 24 | `bytesFromHex` rejects invalid hex |
| 25 | Full pipeline with pepper: encrypt → Morse → decrypt |

### WAV decode tests — `test_decode.py`

Synthesises WAV data using the same parameters as the JS app (44100 Hz, 700 Hz
tone, 60 ms unit), then runs the decode algorithm and compares output.
Python 3 standard library only — no dependencies required.

```bash
python3 test_decode.py
```

| # | What is tested |
|---|---|
| 1 | Normal mixed dots/dashes: A B C D E F |
| 2 | SOS-like pattern |
| 3 | Digits 1 2 3 4 |
| 4 | All-dashes — unimodal long input (hex `0` = `-----`) |
| 5 | All-dots — unimodal short input (hex `5` = `.....`) |
| 6 | Single character |
| 7 | Dash-heavy mixed pattern (1 0 1 0) |
| 8 | Cipher-like mixed long string |
| 9 | WAV with added leading/trailing silence is decoded correctly |
| 10 | Stereo WAV (two-channel) decodes to same result as mono |
| 11 | All 16 hex Morse characters round-trip |
| 12 | Long cipher-like hex payload |
| 13 | Rapid alternating dots and dashes (A B A B A B) |
| 14 | Word gap `/` detection |
| 15 | Variable speed — faster unit (30 ms) |
| 16 | Variable speed — slower unit (120 ms) |

### Run all tests

```bash
node test_crypto.mjs && python3 test_decode.py
```

Both suites exit with code `0` on success and `1` on failure, so they work in CI.

---

## Security considerations

- **Use a strong, unique password (14+ chars or a passphrase).** The security of your message depends
  entirely on the password. Short or common passwords are the only real
  weakness in this system.
- **Share the password out-of-band.** Don't send the password in the same
  channel as the WAV file.
- **Audio duration leaks approximate message length.** WAV duration is
  proportional to ciphertext length. This is an inherent property of the
  Morse-audio transport — not a flaw in the cryptography.
- **PBKDF2 at 150k iterations** makes offline brute-force expensive but not
  impossible for very short passwords. Use 12+ random characters for sensitive
  messages.

---

## Browser compatibility

Requires a modern browser with Web Crypto API support (all evergreen browsers
since ~2020: Chrome, Firefox, Safari, Edge).

---

## License

[MIT](LICENSE) — do whatever you like, no warranty.

---

**Dedicated to my Dad — a Navy veteran who knew Morse code.
We love you and miss you.**
