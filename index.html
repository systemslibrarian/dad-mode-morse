<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Encrypted Morse Messenger ‚Äì AES + Sound</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0a0a0a;
      color: #00ff88;
      padding: 22px;
      max-width: 1000px;
      margin: auto;
      line-height: 1.6;
    }

    .container { background: #111; padding: 22px; border-radius: 12px; border: 1px solid #00ff88; }
    label { display: block; margin: 15px 0 5px; font-weight: bold; }

    input[type="text"], input[type="password"], textarea {
      width: 100%;
      padding: 12px;
      background: #1a1a1a;
      color: #00ff88;
      border: 1px solid #00aa66;
      border-radius: 6px;
      font-family: monospace;
      font-size: 16px;
      box-sizing: border-box;
    }

    .password-row { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 15px 0; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }

    button {
      padding: 12px 18px;
      background: #00ff88;
      color: black;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      margin: 10px 6px 10px 0;
    }
    button:hover { background: #33ffaa; }
    button.paused { background: #ffaa00; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* ===== Header hero (keep image here; bigger) ===== */
    .hero {
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 14px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(0,255,136,0.06), rgba(0,0,0,0));
      border: 1px solid rgba(0,255,136,0.25);
      margin-bottom: 14px;
    }
    .hero-left {
      display: flex;
      align-items: center;
      gap: 14px;
      min-width: 0;
      flex: 1 1 auto;
    }
    #turtleHeaderImg{
      width: 260px;          /* bigger header image */
      max-width: 100%;
      height: auto;
      border-radius: 16px;
      background: #000;
      border: 1px solid rgba(0,255,136,0.25);
      box-shadow: 0 0 18px rgba(0,255,136,0.12);
      flex: 0 0 auto;
      display: block;
    }
    .hero-text { min-width: 0; }
    .hero-title {
      font-size: 28px;
      font-weight: 800;
      margin: 0;
      line-height: 1.2;
    }
    .hero-sub {
      margin: 6px 0 0;
      color: #88ffcc;
      font-family: monospace;
      opacity: 0.95;
    }
    .tx-badge {
      font-family: monospace;
      font-weight: bold;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #00aa66;
      color: #88ffcc;
      background: #0b140b;
      flex: 0 0 auto;
      text-align: center;
      min-width: 104px;
    }
    .tx-on .tx-badge {
      color: #00ff88;
      border-color: #00ff88;
      background: #041a10;
    }
    @media (max-width: 640px) {
      .hero { flex-direction: column; align-items: flex-start; }
      #turtleHeaderImg { width: 100%; max-width: 380px; }
      .tx-badge { align-self: stretch; }
      .hero-title { font-size: 24px; }
    }
    /* ===== end hero ===== */

    /* ===== Transmit row with MP4 next to Transmit ===== */
    .tx-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:16px;
      flex-wrap:wrap;
      margin: 12px 0;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,136,0.18);
      background: rgba(0,0,0,0.12);
    }
    .tx-row-left{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    #turtleTxVid{
      width: 240px;
      max-width: 100%;
      height: auto;
      border-radius: 14px;
      background:#000;
      border: 1px solid rgba(0,255,136,0.35);
      box-shadow: 0 0 14px rgba(0,255,136,0.08);
    }
    .tx-row.tx-on #turtleTxVid{
      outline: 2px solid rgba(0,255,136,0.55);
      box-shadow: 0 0 18px rgba(0,255,136,0.20);
    }
    /* ===== end tx row ===== */

    #output {
      background: #000;
      padding: 18px;
      border-radius: 8px;
      border: 1px solid #004d33;
      min-height: 220px;
      white-space: pre-wrap;
      font-family: monospace;
      margin-top: 14px;
      overflow-y: auto;
      max-height: 540px;
    }

    #morseOutput { margin: 15px 0; font-size: 18px; word-break: break-word; color: #ccffdd; }
    .copy-btn { font-size: 14px; padding: 8px 14px; }
    .status { color: #88ffcc; font-weight: bold; }
    .error { color: #ff6666; font-weight: bold; }

    .instructions { background: #1a2a1a; padding: 12px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #00ff88; }
    .decrypt-section {
      margin-top: 46px;
      padding: 22px 18px;
      background: #0d1a0d;
      border-radius: 10px;
      border: 1px solid #006633;
    }
    .mini { font-size: 0.95em; color:#88ffcc; }
    .hr { height: 1px; background:#0a3; opacity: 0.4; margin: 14px 0; }

    .audio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .file-chip {
      border: 1px solid rgba(0,255,136,0.35);
      background: rgba(0,0,0,0.25);
      color: #88ffcc;
      border-radius: 999px;
      padding: 8px 12px;
      font-family: monospace;
      font-size: 14px;
    }

    /* ===== Help tooltip ===== */
    .help-tip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #00aa66;
      color: #00aa66;
      font-size: 11px;
      font-weight: bold;
      cursor: default;
      position: relative;
      margin-left: 5px;
      vertical-align: middle;
      user-select: none;
      font-family: Arial, sans-serif;
      line-height: 1;
    }
    .help-tip:hover::after {
      content: attr(data-tip);
      position: absolute;
      left: 22px;
      top: 50%;
      transform: translateY(-50%);
      background: #1a2a1a;
      border: 1px solid #00aa66;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      color: #88ffcc;
      white-space: normal;
      width: 270px;
      z-index: 999;
      pointer-events: none;
      font-family: monospace;
      line-height: 1.5;
    }
    @media (max-width: 640px) {
      .help-tip:hover::after { left: auto; right: 0; top: 22px; transform: none; }
    }

    /* ===== Signal strength slider ===== */
    .signal-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 8px 0 4px;
      font-size: 14px;
      color: #88ffcc;
      padding: 0 2px;
    }
    .signal-row label { margin: 0; font-weight: bold; font-size: 14px; color: #88ffcc; }
    #signalSlider {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(to right, #ff4444, #ffaa00, #00ff88);
      outline: none;
      cursor: pointer;
      width: 130px;
      flex: 0 0 auto;
    }
    #signalSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #00ff88;
      border: 2px solid #004422;
      cursor: pointer;
    }
    #signalSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #00ff88;
      border: 2px solid #004422;
      cursor: pointer;
    }
    #signalValueLabel {
      font-family: monospace;
      font-size: 13px;
      color: #ccffdd;
      min-width: 210px;
    }

    /* ===== Decode progress bar ===== */
    #decodeProgress {
      display: none;
      margin: 12px 0 4px;
      background: #0c180c;
      border: 1px solid rgba(0,255,136,0.22);
      border-radius: 8px;
      padding: 10px 14px 12px;
      font-family: monospace;
      font-size: 13px;
    }
    #decodeProgressLabel {
      color: #88ffcc;
      display: block;
      margin-bottom: 6px;
    }
    #decodeProgressTrack {
      background: #0a2a0a;
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
      border: 1px solid rgba(0,255,136,0.15);
    }
    #decodeProgressBar {
      height: 100%;
      border-radius: 4px;
      background: linear-gradient(to right, #00aa66, #00ff88);
      width: 0%;
      transition: width 0.25s ease;
    }
    /* ===== end decode progress ===== */

    /* ===== Toast notification ===== */
    #toastMsg {
      position: fixed;
      bottom: 28px;
      right: 28px;
      background: #1a2a1a;
      border: 1px solid #00aa66;
      color: #88ffcc;
      padding: 12px 18px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      z-index: 9999;
      box-shadow: 0 4px 18px rgba(0,255,136,0.15);
      max-width: 320px;
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.3s, transform 0.3s;
      pointer-events: none;
    }
    #toastMsg.show { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>

<div class="container">
  <!-- Header image stays here -->
  <div class="hero" id="heroVisual">
    <div class="hero-left">
      <!-- Put turtle.png next to index.html -->
      <img id="turtleHeaderImg" src="./turtle.png" alt="Turtle transmitting Morse code" />
      <div class="hero-text">
        <div class="hero-title">Encrypted Morse Messenger</div>
        <div class="hero-sub">Encrypt ‚Üí Morse ‚Üí Beep audio (pause/resume/stop) ‚Üí Decrypt</div>
      </div>
    </div>
    <div id="txBadge" class="tx-badge" aria-live="polite">IDLE</div>
  </div>

  <div class="instructions">
    <strong>How to use:</strong><br>
    1. Enter message + password.<br>
    2. Click <strong>Transmit</strong> &rarr; Morse generated (turtle video plays).<br>
    3. Copy Morse, play audio, or download the audio WAV.<br>
    4. Share the WAV or the Morse string with the recipient.<br>
    5. Recipient uploads the WAV and clicks <strong>Decode WAV &rarr; Morse</strong>, or pastes the Morse string directly, then enters the same password and clicks <strong>Decrypt</strong>.<br><br>
    <em>Security:</em> AES-256-GCM with random salt/IV + authentication (PBKDF2-SHA256).
  </div>

  <label for="message">Message:</label>
  <textarea id="message" rows="3" placeholder="Your secret message..."></textarea>

  <label for="password">Password (for encryption):</label>
  <div class="password-row">
    <input type="password" id="password" placeholder="Strong password (don‚Äôt reuse)" />
    <label class="checkbox-row" style="margin:0;">
      <input type="checkbox" id="showPw" />
      Show
    </label>
  </div>

  <!-- Transmit + video side-by-side -->
  <div class="tx-row" id="txRow">
    <div class="tx-row-left">
      <button id="txBtn">Transmit</button>
      <button id="clearBtn">Clear</button>
    </div>

    <!-- Put turtle.mp4 next to index.html -->
    <video id="turtleTxVid" preload="auto" playsinline poster="./turtle.png">
      <source src="./turtle.mp4" type="video/mp4" />
      Your browser does not support the video tag.
    </video>
  </div>

  <!-- Signal strength slider -->
  <div class="signal-row">
    <label for="signalSlider">&#x1F4E1; Signal:</label>
    <input type="range" id="signalSlider" min="0" max="100" value="100" />
    <span id="signalValueLabel">100% &mdash; Crystal clear</span>
  </div>

  <div id="output"></div>

  <div class="decrypt-section">
    <div class="mini" style="margin-bottom:10px;">
      Upload a Morse WAV to play it back or click <strong>Decode WAV &rarr; Morse</strong> to extract the Morse code automatically.
    </div>
    <div class="audio-row">
      <input id="audioUpload" type="file" accept="audio/wav,audio/*" />
      <span id="audioUploadName" class="file-chip">No audio loaded</span>
      <button id="playUploadedBtn" disabled>Play Uploaded Audio</button>
      <button id="stopUploadedBtn" disabled>Stop Uploaded Audio</button>
      <button id="decodeWavBtn" disabled>Decode WAV ‚Üí Morse</button>
    </div>
    <audio id="uploadedAudio" controls style="width:100%; margin-top:10px; display:none;"></audio>

    <div id="decodeProgress">
      <span id="decodeProgressLabel">Idle</span>
      <div id="decodeProgressTrack"><div id="decodeProgressBar"></div></div>
    </div>

    <h3>Decrypt a received message</h3>
    <p class="mini">Enter the same password used to encrypt the message.</p>

    <label for="decryptPassword">Password for decryption:</label>
    <div class="password-row">
      <input type="password" id="decryptPassword" placeholder="Re-enter the same password here" />
      <label class="checkbox-row" style="margin:0;">
        <input type="checkbox" id="showDecPw" />
        Show
      </label>
    </div>

    <label for="morseInput">Paste received Morse code here:</label>
    <textarea id="morseInput" rows="5" placeholder="Paste the full Morse string here..."></textarea>

    <div class="row" style="margin-top: 10px;">
      <button id="decBtn">Decrypt</button>
    </div>
  </div>
</div>

<script>
/** =========================
 *  MORSE <-> HEX
 *  ========================= */
const hexMorseDict = {
  '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....',
  '6':'-....','7':'--...','8':'---..','9':'----.','A':'.-','B':'-...',
  'C':'-.-.','D':'-..','E':'.','F':'..-.'
};
const reverseHexMorse = Object.fromEntries(Object.entries(hexMorseDict).map(([k,v])=>[v,k]));

function toMorseHex(hex) {
  return hex.toUpperCase().split('')
    .map(c => hexMorseDict[c] || '')
    .filter(Boolean)
    .join(' ');
}

function morseToHex(morse) {
  const groups = morse.trim().split(/\s+/).filter(Boolean);
  let hex = '';
  let invalid = false;
  for (const g of groups) {
    const ch = reverseHexMorse[g];
    if (!ch) { invalid = true; hex += '?'; }
    else hex += ch;
  }
  return { hex: hex.toLowerCase(), invalid };
}

/** =========================
 *  AES-GCM (PBKDF2)
 *  ========================= */
async function aesGcmEncrypt(plaintext, password) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["encrypt"]
  );

  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(plaintext));

  const combined = new Uint8Array(salt.length + iv.length + ct.byteLength);
  combined.set(salt,0);
  combined.set(iv, salt.length);
  combined.set(new Uint8Array(ct), salt.length + iv.length);

  const hex = Array.from(combined).map(b=>b.toString(16).padStart(2,'0')).join('');
  return { hex };
}

async function aesGcmDecrypt(hex, password) {
  if (!/^[0-9a-f]+$/i.test(hex) || hex.length < (16+12+1)*2) {
    throw new Error("Invalid hex payload length/content");
  }

  const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b=>parseInt(b,16)));
  const salt = bytes.slice(0,16);
  const iv   = bytes.slice(16,28);
  const data = bytes.slice(28);

  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["decrypt"]
  );

  const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
  return new TextDecoder().decode(decrypted);
}

/** =========================
 *  Badge + row highlight
 *  ========================= */
function setTxVisual(on, label) {
  const badge = document.getElementById("txBadge");
  const txRow = document.getElementById("txRow");
  if (txRow) {
    if (on) txRow.classList.add("tx-on");
    else txRow.classList.remove("tx-on");
  }
  if (badge) badge.textContent = label || (on ? "TRANSMIT" : "IDLE");
}

/** =========================
 *  TURTLE TX VIDEO (next to Transmit) - reliable play
 *  ========================= */
const turtleTxVid = document.getElementById("turtleTxVid");
let turtleTxStopTimer = null;
let turtleTxStartedAt = 0;
const TURTLE_TX_MIN_MS = 2500; // keep animation visible at least this long

function waitForCanPlay(video, timeoutMs = 5000) {
  return new Promise((resolve, reject) => {
    if (!video) return reject(new Error("No video element"));

    // HAVE_FUTURE_DATA or better
    if (video.readyState >= 3) return resolve();

    const onCanPlay = () => { cleanup(); resolve(); };
    const onError = () => { cleanup(); reject(new Error("Video error loading")); };

    const t = setTimeout(() => {
      cleanup();
      reject(new Error("Timed out waiting for video to be ready"));
    }, timeoutMs);

    function cleanup() {
      clearTimeout(t);
      video.removeEventListener("canplay", onCanPlay);
      video.removeEventListener("error", onError);
    }

    video.addEventListener("canplay", onCanPlay, { once: true });
    video.addEventListener("error", onError, { once: true });
  });
}

async function playTurtleDuringTx() {
  if (!turtleTxVid) return;

  // Reliability: keep it muted (no audio) and playsinline.
  turtleTxVid.muted = true;
  turtleTxVid.playsInline = true;

  // Keep the animation visible during transmit; loop so short clips don't "flash".
  turtleTxVid.loop = true;

  // Slow it down slightly so it's easier to notice.
  turtleTxVid.playbackRate = 0.75;

  turtleTxStartedAt = performance.now();

  try { turtleTxVid.currentTime = 0; } catch (_) {}

  // Attempt 1: play directly (user gesture from clicking Transmit should allow).
  try {
    const p = turtleTxVid.play();
    if (p && typeof p.then === "function") await p;
    return;
  } catch (_) { /* fall through */ }

  // Attempt 2: load + wait
  try {
    turtleTxVid.load();
    await waitForCanPlay(turtleTxVid, 6000);
    const p = turtleTxVid.play();
    if (p && typeof p.then === "function") await p;
  } catch (e) {
    console.warn("Turtle TX video unavailable:", e.message);
  }
}

function stopTurtleTx(force = false) {
  try {
    if (turtleTxStopTimer) {
      clearTimeout(turtleTxStopTimer);
      turtleTxStopTimer = null;
    }
    if (!turtleTxVid) return;

    const elapsed = performance.now() - (turtleTxStartedAt || 0);
    const remaining = Math.max(0, TURTLE_TX_MIN_MS - elapsed);

    // If we haven't shown the animation long enough, delay the stop a bit
    // (unless force=true, e.g. Clear button).
    if (!force && remaining > 0) {
      turtleTxStopTimer = setTimeout(() => stopTurtleTx(true), remaining);
      return;
    }

    turtleTxVid.loop = false;
    turtleTxVid.playbackRate = 1.0;
    turtleTxVid.pause();
    try { turtleTxVid.currentTime = 0; } catch (_) {}
  } catch (_) {}
  setTxVisual(false, "READY");
}
/** =========================
 *  SAFE DOM HELPERS
 *  ========================= */
const outputEl = document.getElementById('output');

function setStatus(text, cls = "status") {
  outputEl.innerHTML = "";
  const s = document.createElement("strong");
  s.className = cls;
  s.textContent = text;
  outputEl.appendChild(s);
}

function appendLine(label, value) {
  const div = document.createElement("div");
  const b = document.createElement("strong");
  b.textContent = label + " ";
  div.appendChild(b);
  div.appendChild(document.createTextNode(value));
  outputEl.appendChild(div);
}

/** =========================
 *  AUDIO ENGINE (live beeps)
 *  ========================= */
const MorseTiming = {
  unitMs: 60,
  freqHz: 700,
  gain: 0.4,
};

window.morseAudio = {
  audioCtx: null,
  gainNode: null,
  playing: false,
  paused: true,
  endTimer: null,
};

async function ensureAudio() {
  const st = window.morseAudio;
  if (!st.audioCtx || st.audioCtx.state === "closed") {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = ctx.createGain();
    gainNode.gain.value = MorseTiming.gain;
    gainNode.connect(ctx.destination);
    st.audioCtx = ctx;
    st.gainNode = gainNode;
    st.playing = false;
    st.paused = true;
  }
  if (st.audioCtx.state === "suspended") {
    await st.audioCtx.resume();
  }
}

function resetPlaybackUI() {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  if (pp) {
    pp.textContent = "Play Morse Sound";
    pp.classList.remove("paused");
  }
  if (stopBtn) stopBtn.disabled = true;
}

function stopMorsePlayback() {
  const st = window.morseAudio;
  if (st.endTimer) {
    clearTimeout(st.endTimer);
    st.endTimer = null;
  }
  if (st.audioCtx && st.audioCtx.state !== "closed") {
    st.audioCtx.close();
  }
  st.audioCtx = null;
  st.gainNode = null;
  st.playing = false;
  st.paused = true;
  resetPlaybackUI();
}

async function playMorse(morseStr) {
  if (!morseStr) throw new Error("No Morse to play");

  stopMorsePlayback();
  await ensureAudio();

  const st = window.morseAudio;
  const ctx = st.audioCtx;
  const gainNode = st.gainNode;

  const sigLevel = signalQuality();
  const degraded = degradeMorse(morseStr, sigLevel);
  const jitterFactor = (100 - sigLevel) / 100;

  const unit = MorseTiming.unitMs;
  const dotMs = unit;
  const dashMs = unit * 3;
  const elemGapMs = unit;
  const letterGapMs = unit * 3;
  const wordGapMs = unit * 7;

  const playBeep = (startTimeSec, durationSec) => {
    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(MorseTiming.freqHz, startTimeSec);
    osc.connect(gainNode);
    osc.start(startTimeSec);
    osc.stop(startTimeSec + durationSec);
  };

  let t = ctx.currentTime + 0.08;

  for (const sym of degraded) {
    if (jitterFactor > 0) t += Math.random() * jitterFactor * unit * 0.25 / 1000;
    if (sym === ".") {
      playBeep(t, dotMs / 1000);
      t += (dotMs + elemGapMs) / 1000;
    } else if (sym === "-") {
      playBeep(t, dashMs / 1000);
      t += (dashMs + elemGapMs) / 1000;
    } else if (sym === " ") {
      t += (letterGapMs) / 1000;
    } else if (sym === "/") {
      t += (wordGapMs) / 1000;
    }
  }

  st.playing = true;
  st.paused = false;

  setTxVisual(true, "BEEPING");

  const totalMs = Math.max(0, (t - ctx.currentTime) * 1000);
  st.endTimer = setTimeout(() => {
    st.playing = false;
    st.paused = true;
    resetPlaybackUI();
    setTxVisual(false, "READY");
  }, totalMs + 200);
}

async function toggleMorsePlayback(morseStr) {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  const st = window.morseAudio;

  if (!st.playing) {
    await playMorse(morseStr);
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    stopBtn.disabled = false;
    return;
  }

  if (!st.paused) {
    await st.audioCtx.suspend();
    st.paused = true;
    pp.textContent = "Resume Playback";
    pp.classList.remove("paused");
    setTxVisual(true, "PAUSED");
  } else {
    await st.audioCtx.resume();
    st.paused = false;
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    setTxVisual(true, "BEEPING");
  }
}

/** =========================
 *  WAV export (downloadable)
 *  ========================= */
function buildMorseTimelineMs(morseStr, unitMs) {
  const dot = unitMs;
  const dash = unitMs * 3;
  const elemGap = unitMs;
  const letterGap = unitMs * 3;
  const wordGap = unitMs * 7;
  const timeline = [];
  for (const sym of morseStr) {
    if (sym === ".") {
      timeline.push({ tone: true, ms: dot });
      timeline.push({ tone: false, ms: elemGap });
    } else if (sym === "-") {
      timeline.push({ tone: true, ms: dash });
      timeline.push({ tone: false, ms: elemGap });
    } else if (sym === " ") {
      timeline.push({ tone: false, ms: letterGap });
    } else if (sym === "/") {
      timeline.push({ tone: false, ms: wordGap });
    }
  }
  while (timeline.length && timeline[timeline.length - 1].tone === false) timeline.pop();
  return timeline;
}

function floatTo16BitPCM(view, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
  }
}

function writeString(view, offset, str) {
  for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
}

function encodeWAV(samples, sampleRate) {
  const buffer = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + samples.length * 2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, samples.length * 2, true);

  floatTo16BitPCM(view, 44, samples);
  return new Blob([view], { type: 'audio/wav' });
}

function synthMorseWavBlob(morseStr, opts = {}) {
  const sampleRate = opts.sampleRate || 44100;
  const freq = opts.freqHz || MorseTiming.freqHz;
  const unit = opts.unitMs || MorseTiming.unitMs;
  const volume = (typeof opts.volume === "number") ? opts.volume : 0.35;
  const noise = typeof opts.noise === "number" ? opts.noise : 0; // 0‚Äì1 static noise level
  const sigLevel = typeof opts.signalLevel === "number" ? opts.signalLevel : 100;

  morseStr = degradeMorse(morseStr, sigLevel); // apply symbol errors

  const timeline = buildMorseTimelineMs(morseStr, unit);
  const totalMs = timeline.reduce((a, x) => a + x.ms, 0);
  const totalSamples = Math.ceil(totalMs / 1000 * sampleRate);
  const samples = new Float32Array(totalSamples);

  let idx = 0;
  let phase = 0;
  const phaseInc = 2 * Math.PI * freq / sampleRate;
  const fadeMs = Math.min(6, unit * 0.2);
  const fadeSamples = Math.max(1, Math.floor(fadeMs / 1000 * sampleRate));

  const writeSegment = (tone, ms) => {
    const n = Math.floor(ms / 1000 * sampleRate);
    for (let i = 0; i < n && idx < samples.length; i++) {
      let v = 0;
      if (tone) {
        let amp = volume;
        if (i < fadeSamples) amp *= (i / fadeSamples);
        if (n - i - 1 < fadeSamples) amp *= ((n - i - 1) / fadeSamples);
        v = Math.sin(phase) * amp;
        phase += phaseInc;
        if (phase > 2*Math.PI) phase -= 2*Math.PI;
      }
      if (noise > 0) v = Math.max(-1, Math.min(1, v + (Math.random() * 2 - 1) * noise * (tone ? 0.06 : 0.14)));
      samples[idx++] = v;
    }
  };

  for (const seg of timeline) writeSegment(seg.tone, seg.ms);
  return encodeWAV(samples, sampleRate);
}

/** =========================
 *  UI: TRANSMIT / CLEAR / DECRYPT
 *  ========================= */
function clearAll() {
  stopMorsePlayback();
  stopTurtleTx(true);
  setTxVisual(false, "IDLE");

  // Reset fields
  document.getElementById('message').value = "";
  document.getElementById('password').value = "";
  document.getElementById('morseInput').value = "";
  document.getElementById('decryptPassword').value = "";

  // Reset uploaded audio
  if (uploadedAudioUrl) {
    try { URL.revokeObjectURL(uploadedAudioUrl); } catch (_) {}
    uploadedAudioUrl = null;
  }
  if (audioUpload) audioUpload.value = "";
  if (uploadedAudio) {
    uploadedAudio.pause();
    uploadedAudio.removeAttribute("src");
    uploadedAudio.load();
    uploadedAudio.style.display = "none";
  }
  if (audioUploadName) audioUploadName.textContent = "No audio loaded";
  if (playUploadedBtn) playUploadedBtn.disabled = true;
  if (stopUploadedBtn) stopUploadedBtn.disabled = true;
  if (decodeWavBtn) decodeWavBtn.disabled = true;

  const progressWrap = document.getElementById("decodeProgress");
  if (progressWrap) progressWrap.style.display = "none";

  setStatus("Ready...");
}

async function runDadMode() {
  const msg = document.getElementById('message').value.trim();
  const pw  = document.getElementById('password').value;

  if (!msg) { setStatus("Enter message", "error"); return; }
  if (!pw || pw.length < 8) { setStatus("Longer password recommended (8+)", "error"); return; }

  setTxVisual(true, "ENCRYPT");
  setStatus("Encrypting (AES-256-GCM)...", "status");

  // Prevent double-click transmit while working
  const txBtn = document.getElementById("txBtn");
  if (txBtn) txBtn.disabled = true;

  // play the MP4 next to the Transmit button (reliably)
  playTurtleDuringTx();

  try {
    const { hex } = await aesGcmEncrypt(msg, pw);
    const morse = toMorseHex(hex);

    outputEl.innerHTML = "";
    (() => {
      const d = document.createElement("div");
      const b = document.createElement("strong");
      b.textContent = "Encrypted hex (shortened): ";
      const tip = document.createElement("span");
      tip.className = "help-tip";
      tip.textContent = "?";
      tip.setAttribute("data-tip",
        "First 32 hex chars = random salt (16 bytes). " +
        "Next 24 hex chars = random IV/nonce (12 bytes). " +
        "These are NOT secret \u2014 bundled so the same password+message never produces the same ciphertext twice. " +
        "The rest is AES-GCM ciphertext + authentication tag.");
      b.appendChild(tip);
      d.appendChild(b);
      d.appendChild(document.createTextNode(`${hex.slice(0,80)}\u2026 (${hex.length} chars)`));
      outputEl.appendChild(d);
    })();

    const hr = document.createElement("div");
    hr.className = "hr";
    outputEl.appendChild(hr);

    const morseDiv = document.createElement("div");
    morseDiv.id = "morseOutput";

    const morseTitle = document.createElement("strong");
    morseTitle.textContent = "Morse to transmit:";
    morseDiv.appendChild(morseTitle);
    morseDiv.appendChild(document.createElement("br"));

    const morseText = document.createElement("div");
    morseText.textContent = morse;
    morseDiv.appendChild(morseText);
    outputEl.appendChild(morseDiv);

    const btnRow = document.createElement("div");
    btnRow.className = "audio-row";

    const copyBtn = document.createElement("button");
    copyBtn.className = "copy-btn";
    copyBtn.textContent = "Copy Morse";
    copyBtn.addEventListener("click", async () => {
      await navigator.clipboard.writeText(morse);
      alert("Copied!");
    });

    const playPauseBtn = document.createElement("button");
    playPauseBtn.id = "playPauseBtn";
    playPauseBtn.textContent = "Play Morse Sound";
    playPauseBtn.addEventListener("click", () => {
      toggleMorsePlayback(morse).catch(err => alert("Audio error: " + err.message));
    });

    const stopBtn = document.createElement("button");
    stopBtn.id = "stopBtn";
    stopBtn.textContent = "Stop";
    stopBtn.disabled = true;
    stopBtn.addEventListener("click", stopMorsePlayback);

    const wavBtn = document.createElement("button");
    wavBtn.textContent = "Download Morse WAV";
    wavBtn.addEventListener("click", () => {
      try {
        const sig = signalQuality();
        const blob = synthMorseWavBlob(morse, { unitMs: MorseTiming.unitMs, freqHz: MorseTiming.freqHz, noise: (100 - sig) / 100, signalLevel: sig });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `morse_${new Date().toISOString().replace(/[:.]/g,'-')}.wav`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      } catch (e) {
        alert("Could not generate WAV: " + (e?.message || String(e)));
      }
    });

    btnRow.appendChild(copyBtn);
    btnRow.appendChild(playPauseBtn);
    btnRow.appendChild(stopBtn);
    btnRow.appendChild(wavBtn);
    outputEl.appendChild(btnRow);

    // End transmit visuals (honors minimum visible animation time)
    stopTurtleTx(false);

  } catch (e) {
    setTxVisual(false, "IDLE");
    stopTurtleTx(true);
    setStatus("Error: " + (e?.message || String(e)), "error");
  } finally {
    const txBtn = document.getElementById("txBtn");
    if (txBtn) txBtn.disabled = false;
  }
}

async function decryptDadMode() {
  const morse = document.getElementById('morseInput').value.trim();
  const pw = document.getElementById('decryptPassword').value;

  if (!morse) { alert("Paste Morse first"); return; }
  if (!pw) { alert("Enter decryption password"); return; }

  try {
    const { hex, invalid } = morseToHex(morse);
    if (invalid || hex.includes('?')) throw new Error("Invalid Morse ‚Äì check copy/paste or typos");

    const plaintext = await aesGcmDecrypt(hex, pw);

    alert(`Success!\n\nOriginal message:\n${plaintext}`);

    const br = document.createElement("br");
    outputEl.appendChild(br);

    const safe = document.createElement("div");
    safe.className = "status";
    safe.style.color = "#88ffcc";
    safe.textContent = `Decrypted: ${plaintext}`;
    outputEl.appendChild(safe);

  } catch (err) {
    alert(`Failed: ${err.message}\n\nLikely causes:\n- Wrong password\n- Incomplete/invalid Morse\n- Typos in Morse`);
  }
}

/** =========================
 *  Uploaded WAV playback + decode
 *  ========================= */
const audioUpload = document.getElementById("audioUpload");
const uploadedAudio = document.getElementById("uploadedAudio");
let uploadedAudioUrl = null;
const audioUploadName = document.getElementById("audioUploadName");
const playUploadedBtn = document.getElementById("playUploadedBtn");
const stopUploadedBtn = document.getElementById("stopUploadedBtn");
const decodeWavBtn = document.getElementById("decodeWavBtn");

audioUpload.addEventListener("change", () => {
  const file = audioUpload.files && audioUpload.files[0];
  // Reset progress bar whenever a new file is chosen
  const progressWrap = document.getElementById("decodeProgress");
  if (progressWrap) progressWrap.style.display = "none";

  if (!file) {
    audioUploadName.textContent = "No audio loaded";
    uploadedAudio.style.display = "none";
    playUploadedBtn.disabled = true;
    stopUploadedBtn.disabled = true;
    decodeWavBtn.disabled = true;
    return;
  }
  audioUploadName.textContent = file.name;
  if (uploadedAudioUrl) {
    try { URL.revokeObjectURL(uploadedAudioUrl); } catch (_) {}
    uploadedAudioUrl = null;
  }
  const url = URL.createObjectURL(file);
  uploadedAudioUrl = url;
  uploadedAudio.src = url;
  uploadedAudio.style.display = "block";
  playUploadedBtn.disabled = false;
  stopUploadedBtn.disabled = false;
  decodeWavBtn.disabled = false;
  showToast("Audio loaded \u2014 click \u201CDecode WAV \u2192 Morse\u201D to extract Morse code.");
});

playUploadedBtn.addEventListener("click", () => {
  uploadedAudio.play().catch(() => {});
});

stopUploadedBtn.addEventListener("click", () => {
  uploadedAudio.pause();
  uploadedAudio.currentTime = 0;
});

decodeWavBtn.addEventListener("click", () => {
  const file = audioUpload.files && audioUpload.files[0];
  if (file) decodeMorseWav(file);
});

/** Update the decode progress bar. */
function setDecodeProgress(label, pct, isError = false) {
  const wrap = document.getElementById("decodeProgress");
  const lbl  = document.getElementById("decodeProgressLabel");
  const bar  = document.getElementById("decodeProgressBar");
  if (!wrap) return;
  wrap.style.display = "block";
  lbl.textContent    = label;
  lbl.style.color    = isError ? "#ff6666" : "#88ffcc";
  bar.style.width    = pct + "%";
  bar.style.background = isError
    ? "linear-gradient(to right, #aa2200, #ff4444)"
    : "linear-gradient(to right, #00aa66, #00ff88)";
}

/**
 * Decode a Morse WAV file into a Morse string and populate the decrypt input.
 * Works by computing RMS energy in short frames, thresholding to get
 * tone-on/tone-off runs, then classifying by duration into dots, dashes, and gaps.
 */
async function decodeMorseWav(file) {
  decodeWavBtn.disabled = true;
  decodeWavBtn.textContent = "Decoding\u2026";

  try {
    setDecodeProgress("\uD83D\uDCE5 Step 1 / 6 \u2014 Reading audio file\u2026", 8);
    const arrayBuffer = await file.arrayBuffer();

    setDecodeProgress("\uD83C\uDFBC Step 2 / 6 \u2014 Decoding audio data\u2026", 22);
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let audioBuffer;
    try {
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    } finally {
      audioCtx.close();
    }

    // Mix down to mono
    setDecodeProgress("\uD83D\uDD0A Step 3 / 6 \u2014 Mixing to mono & measuring energy\u2026", 38);
    const sampleRate = audioBuffer.sampleRate;
    const numChannels = audioBuffer.numberOfChannels;
    const length = audioBuffer.length;
    const mono = new Float32Array(length);
    for (let ch = 0; ch < numChannels; ch++) {
      const data = audioBuffer.getChannelData(ch);
      for (let i = 0; i < length; i++) mono[i] += data[i] / numChannels;
    }

    // RMS energy in 5 ms frames
    const frameMs = 5;
    const frameSamples = Math.max(1, Math.floor(sampleRate * frameMs / 1000));
    const numFrames = Math.floor(length / frameSamples);
    const energy = new Float32Array(numFrames);
    for (let f = 0; f < numFrames; f++) {
      const start = f * frameSamples;
      let sum = 0;
      for (let i = 0; i < frameSamples; i++) {
        const v = mono[start + i];
        sum += v * v;
      }
      energy[f] = Math.sqrt(sum / frameSamples);
    }

    // Threshold at 15% of the 95th-percentile energy value
    setDecodeProgress("üìä Step 4 / 6 ‚Äî Detecting tone on/off‚Ä¶", 55);
    const sorted = Array.from(energy).sort((a, b) => a - b);
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const threshold = p95 * 0.15;
    if (p95 < 1e-5) throw new Error("Audio appears silent ‚Äî is this a Morse WAV?");

    // Binary on/off
    const binary = Array.from(energy).map(e => e > threshold ? 1 : 0);

    // Run-length encoding ‚Üí [{val, ms}]
    const runs = [];
    let cur = binary[0], count = 1;
    for (let i = 1; i < binary.length; i++) {
      if (binary[i] === cur) { count++; }
      else { runs.push({ val: cur, ms: count * frameMs }); cur = binary[i]; count = 1; }
    }
    runs.push({ val: cur, ms: count * frameMs });

    // Strip leading/trailing silence
    while (runs.length && runs[0].val === 0) runs.shift();
    while (runs.length && runs[runs.length - 1].val === 0) runs.pop();
    if (!runs.length) throw new Error("No tone detected ‚Äî is this a Morse WAV?");

    // Estimate unit (dot) length from ON durations.
    // Strategy: find the largest relative jump in sorted ON durations ‚Äî that gap
    // marks the dot/dash boundary. Take the mean of the lower (dot) cluster.
    // Falls back gracefully when all symbols are the same type.
    setDecodeProgress("üî¨ Step 5 / 6 ‚Äî Estimating dot/dash lengths‚Ä¶", 72);
    const onDurs = runs.filter(r => r.val === 1).map(r => r.ms).sort((a, b) => a - b);
    let rawUnit = MorseTiming.unitMs;
    if (onDurs.length) {
      const medDur = onDurs[Math.floor(onDurs.length / 2)];
      let maxRatio = 1, splitIdx = -1;
      for (let i = 0; i < onDurs.length - 1; i++) {
        const ratio = onDurs[i + 1] / (onDurs[i] || 1);
        if (ratio > maxRatio) { maxRatio = ratio; splitIdx = i + 1; }
      }
      if (maxRatio > 1.8 && splitIdx > 0) {
        // bimodal: lower cluster = dots
        const dotCluster = onDurs.slice(0, splitIdx);
        rawUnit = Math.round(dotCluster.reduce((s, v) => s + v, 0) / dotCluster.length);
      } else if (medDur > 100) {
        rawUnit = Math.round(medDur / 3); // unimodal long ‚Üí all dashes
      } else {
        rawUnit = medDur; // unimodal short ‚Üí all dots
      }
    }
    const unitMs = Math.max(20, rawUnit);

    // Classify runs
    setDecodeProgress("üìù Step 6 / 6 ‚Äî Classifying dots & dashes‚Ä¶", 88);
    let morse = "";
    for (const r of runs) {
      if (r.val === 1) {
        morse += r.ms < unitMs * 2 ? "." : "-";
      } else {
        if      (r.ms < unitMs * 2) { /* element gap ‚Äî skip */ }
        else if (r.ms < unitMs * 5) { morse += " "; }   // letter gap
        else                        { morse += " / "; }  // word gap
      }
    }

    morse = morse.trim().replace(/\s*\/\s*/g, " / ").replace(/  +/g, " ");
    if (!morse) throw new Error("Could not extract Morse symbols from audio");

    document.getElementById("morseInput").value = morse;
    document.getElementById("morseInput").scrollIntoView({ behavior: "smooth" });
    setDecodeProgress("\u2705 Done! Morse code extracted \u2014 enter your password and click Decrypt.", 100);

  } catch (e) {
    setDecodeProgress("\u274C Failed: " + (e?.message || String(e)), 100, true);
  } finally {
    decodeWavBtn.disabled = false;
    decodeWavBtn.textContent = "Decode WAV \u2192 Morse";
  }
}

/** =========================
 *  Toast notification
 *  ========================= */
let _toastTimer = null;
function showToast(msg, duration = 3800) {
  const el = document.getElementById("toastMsg");
  if (!el) return;
  if (_toastTimer) { clearTimeout(_toastTimer); _toastTimer = null; }
  el.textContent = msg;
  el.classList.add("show");
  _toastTimer = setTimeout(() => {
    el.classList.remove("show");
    _toastTimer = null;
  }, duration);
}

/** =========================
 *  Signal quality helpers
 *  ========================= */
function signalQuality() {
  const sl = document.getElementById("signalSlider");
  return sl ? parseInt(sl.value, 10) : 100;
}

function signalLabelText(v) {
  if (v >= 100) return "100% \u2014 Crystal clear";
  if (v >= 80)  return v + "% \u2014 Mostly stable";
  if (v >= 50)  return v + "% \u2014 Getting noisy\u2026";
  if (v >= 25)  return v + "% \u2014 Weak signal!";
  if (v > 0)    return v + "% \u2014 Total garbage \uD83D\uDC80";
  return "0% \u2014 Dead air \uD83D\uDC80";
}

/** =========================
 *  Morse degradation (signal simulation)
 *  ========================= */
function degradeMorse(morseStr, signalLevel) {
  if (signalLevel >= 100) return morseStr;
  const errRate = (100 - signalLevel) / 100; // 0 = clean, 1 = chaos
  let out = '';
  for (const c of morseStr) {
    if (c === '.' || c === '-') {
      const r = Math.random();
      if (r < errRate * 0.25) continue;                      // drop element
      if (r < errRate * 0.42) { out += c === '.' ? '-' : '.'; continue; } // flip
      if (r < errRate * 0.52) { out += c + (Math.random() < 0.5 ? '.' : '-'); continue; } // phantom extra
      out += c;
    } else if (c === ' ') {
      out += c;
      if (Math.random() < errRate * 0.35) out += ' '; // extra gap
    } else {
      out += c; // '/' word-gap or other
    }
  }
  return out || morseStr; // fallback to original if degraded to nothing
}

/** =========================
 *  Wire up controls
 *  ========================= */
document.getElementById("txBtn").addEventListener("click", () => runDadMode());
document.getElementById("clearBtn").addEventListener("click", () => clearAll());
document.getElementById("decBtn").addEventListener("click", () => decryptDadMode());

document.getElementById("showPw").addEventListener("change", (e) => {
  document.getElementById("password").type = e.target.checked ? "text" : "password";
});
document.getElementById("showDecPw").addEventListener("change", (e) => {
  document.getElementById("decryptPassword").type = e.target.checked ? "text" : "password";
});

const signalSliderEl = document.getElementById("signalSlider");
const signalValueLabelEl = document.getElementById("signalValueLabel");
if (signalSliderEl) {
  signalSliderEl.addEventListener("input", () => {
    signalValueLabelEl.textContent = signalLabelText(parseInt(signalSliderEl.value, 10));
  });
}

// Helpful console hint if video fails to load
turtleTxVid?.addEventListener("error", () => console.warn("turtle.mp4 failed to load (check filename/path)."));

setStatus("Ready...");
setTxVisual(false, "IDLE");
</script>

<div id="toastMsg"></div>

</body>
</html>
