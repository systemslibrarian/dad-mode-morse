<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Encrypted Morse Messenger – AES + Sound</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0a0a0a;
      color: #00ff88;
      padding: 22px;
      max-width: 1000px;
      margin: auto;
      line-height: 1.6;
    }

    .container { background: #111; padding: 22px; border-radius: 12px; border: 1px solid #00ff88; }
    label { display: block; margin: 15px 0 5px; font-weight: bold; }

    input[type="text"], input[type="password"], textarea {
      width: 100%;
      padding: 12px;
      background: #1a1a1a;
      color: #00ff88;
      border: 1px solid #00aa66;
      border-radius: 6px;
      font-family: monospace;
      font-size: 16px;
      box-sizing: border-box;
    }

    .password-row { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 15px 0; }
    .row { display:flex; gap:10px; flex-wrap: wrap; }

    button {
      padding: 12px 18px;
      background: #00ff88;
      color: black;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      margin: 10px 6px 10px 0;
    }
    button:hover { background: #33ffaa; }
    button.paused { background: #ffaa00; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* ===== Turtle header ===== */
    .hero {
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 14px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(0,255,136,0.06), rgba(0,0,0,0));
      border: 1px solid rgba(0,255,136,0.25);
      margin-bottom: 14px;
    }
    .hero-left {
      display: flex;
      align-items: center;
      gap: 14px;
      min-width: 0;
      flex: 1 1 auto;
    }

    /* Video (uses turtle.mp4). poster uses turtle.png if present. */
    #turtleVid {
      width: 190px;
      height: auto;
      border-radius: 16px;
      background: #000;
      box-shadow: 0 0 0 rgba(0,255,136,0);
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
      flex: 0 0 auto;
      display: block;
    }

    .hero-text { min-width: 0; }
    .hero-title {
      font-size: 28px;
      font-weight: 800;
      margin: 0;
      line-height: 1.2;
    }
    .hero-sub {
      margin: 6px 0 0;
      color: #88ffcc;
      font-family: monospace;
      opacity: 0.95;
    }
    .tx-badge {
      font-family: monospace;
      font-weight: bold;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #00aa66;
      color: #88ffcc;
      background: #0b140b;
      flex: 0 0 auto;
      text-align: center;
      min-width: 92px;
    }
    .tx-on #turtleVid {
      animation: txPulse 0.9s infinite ease-in-out;
      filter: brightness(1.12) saturate(1.2);
      box-shadow: 0 0 22px rgba(0,255,136,0.25);
    }
    .tx-on .tx-badge {
      color: #00ff88;
      border-color: #00ff88;
      background: #041a10;
    }
    @keyframes txPulse {
      0%, 100% { transform: scale(1.00); }
      50%      { transform: scale(1.05); }
    }
    @media (max-width: 640px) {
      .hero { flex-direction: column; align-items: flex-start; }
      #turtleVid { width: 100%; max-width: 360px; }
      .tx-badge { align-self: stretch; }
      .hero-title { font-size: 24px; }
    }
    /* ===== end turtle header ===== */

    #output {
      background: #000;
      padding: 18px;
      border-radius: 8px;
      border: 1px solid #004d33;
      min-height: 220px;
      white-space: pre-wrap;
      font-family: monospace;
      margin-top: 14px;
      overflow-y: auto;
      max-height: 540px;
    }

    #morseOutput { margin: 15px 0; font-size: 18px; word-break: break-word; color: #ccffdd; }
    .copy-btn { font-size: 14px; padding: 8px 14px; }
    .status { color: #88ffcc; font-weight: bold; }
    .error { color: #ff6666; font-weight: bold; }

    .instructions { background: #1a2a1a; padding: 12px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #00ff88; }
    .decrypt-section {
      margin-top: 46px;
      padding: 22px 18px;
      background: #0d1a0d;
      border-radius: 10px;
      border: 1px solid #006633;
    }
    .mini { font-size: 0.95em; color:#88ffcc; }
    .hr { height: 1px; background:#0a3; opacity: 0.4; margin: 14px 0; }

    .audio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .file-chip {
      border: 1px solid rgba(0,255,136,0.35);
      background: rgba(0,0,0,0.25);
      color: #88ffcc;
      border-radius: 999px;
      padding: 8px 12px;
      font-family: monospace;
      font-size: 14px;
    }
  </style>
</head>
<body>

<div class="container">
  <!-- Turtle header / always visible at top -->
  <div class="hero" id="txVisual">
    <div class="hero-left">
      <!-- Put turtle.mp4 (and optionally turtle.png) next to index.html in your repo -->
      <video id="turtleVid" preload="auto" muted playsinline poster="./turtle.png" controls>
        <source src="./turtle.mp4" type="video/mp4" />
        Your browser does not support the video tag.
      </video>

      <div class="hero-text">
        <div class="hero-title">Encrypted Morse Messenger</div>
        <div class="hero-sub">Encrypt → Morse → Beep audio (pause/resume/stop) → Decrypt</div>
      </div>
    </div>
    <div id="txBadge" class="tx-badge" aria-live="polite">IDLE</div>
  </div>

  <div class="instructions">
    <strong>How to use:</strong><br>
    1. Enter message + password.<br>
    2. Click <strong>Transmit</strong> → Morse generated (turtle animates).<br>
    3. Copy Morse, play audio, or download the audio WAV.<br>
    4. Paste Morse in the bottom section + same password → decrypt.<br><br>
    <em>Security:</em> AES-256-GCM with random salt/IV + authentication (PBKDF2-SHA256).
  </div>

  <label for="message">Message:</label>
  <textarea id="message" rows="3" placeholder="Your secret message..."></textarea>

  <label for="password">Password (for encryption):</label>
  <div class="password-row">
    <input type="password" id="password" placeholder="Strong password (don’t reuse)" />
    <label class="checkbox-row" style="margin:0;">
      <input type="checkbox" id="showPw" />
      Show
    </label>
  </div>

  <div class="row" style="margin: 12px 0;">
    <button id="txBtn">Transmit</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div id="output"></div>

  <div class="decrypt-section">
    <div class="mini" style="margin-bottom:10px;">
      Optional: upload a Morse WAV someone shared to you (playback only).
    </div>
    <div class="audio-row">
      <input id="audioUpload" type="file" accept="audio/wav,audio/*" />
      <span id="audioUploadName" class="file-chip">No audio loaded</span>
      <button id="playUploadedBtn" disabled>Play Uploaded Audio</button>
      <button id="stopUploadedBtn" disabled>Stop Uploaded Audio</button>
    </div>
    <audio id="uploadedAudio" controls style="width:100%; margin-top:10px; display:none;"></audio>

    <h3>Decrypt a received message</h3>
    <p class="mini">Enter the same password used to encrypt the message.</p>

    <label for="decryptPassword">Password for decryption:</label>
    <div class="password-row">
      <input type="password" id="decryptPassword" placeholder="Re-enter the same password here" />
      <label class="checkbox-row" style="margin:0;">
        <input type="checkbox" id="showDecPw" />
        Show
      </label>
    </div>

    <label for="morseInput">Paste received Morse code here:</label>
    <textarea id="morseInput" rows="5" placeholder="Paste the full Morse string here..."></textarea>

    <div class="row" style="margin-top: 10px;">
      <button id="decBtn">Decrypt</button>
    </div>
  </div>
</div>

<script>
/** =========================
 *  MORSE <-> HEX
 *  ========================= */
const hexMorseDict = {
  '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....',
  '6':'-....','7':'--...','8':'---..','9':'----.','A':'.-','B':'-...',
  'C':'-.-.','D':'-..','E':'.','F':'..-.'
};
const reverseHexMorse = Object.fromEntries(Object.entries(hexMorseDict).map(([k,v])=>[v,k]));

function toMorseHex(hex) {
  return hex.toUpperCase().split('')
    .map(c => hexMorseDict[c] || '')
    .filter(Boolean)
    .join(' ');
}

function morseToHex(morse) {
  const groups = morse.trim().split(/\s+/).filter(Boolean);
  let hex = '';
  let invalid = false;
  for (const g of groups) {
    const ch = reverseHexMorse[g];
    if (!ch) { invalid = true; hex += '?'; }
    else hex += ch;
  }
  return { hex: hex.toLowerCase(), invalid };
}

/** =========================
 *  AES-GCM (PBKDF2)
 *  ========================= */
async function aesGcmEncrypt(plaintext, password) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["encrypt"]
  );

  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(plaintext));

  const combined = new Uint8Array(salt.length + iv.length + ct.byteLength);
  combined.set(salt,0);
  combined.set(iv, salt.length);
  combined.set(new Uint8Array(ct), salt.length + iv.length);

  const hex = Array.from(combined).map(b=>b.toString(16).padStart(2,'0')).join('');
  return { hex };
}

async function aesGcmDecrypt(hex, password) {
  if (!/^[0-9a-f]+$/i.test(hex) || hex.length < (16+12+1)*2) {
    throw new Error("Invalid hex payload length/content");
  }

  const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b=>parseInt(b,16)));
  const salt = bytes.slice(0,16);
  const iv   = bytes.slice(16,28);
  const data = bytes.slice(28);

  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["decrypt"]
  );

  const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
  return new TextDecoder().decode(decrypted);
}

/** =========================
 *  TURTLE TRANSMIT VISUAL + VIDEO
 *  ========================= */
const turtleVid = document.getElementById("turtleVid");

function setTxVisual(on, label) {
  const container = document.getElementById("txVisual");
  const badge = document.getElementById("txBadge");
  if (!container || !badge) return;

  if (on) container.classList.add("tx-on");
  else container.classList.remove("tx-on");

  badge.textContent = label || (on ? "TRANSMIT" : "IDLE");
}

async function playTurtleOnce() {
  // Play the turtle video on Transmit click. Robust against “not ready yet”.
  try {
    if (!turtleVid) return;

    // Make it clearly visible that it’s animating
    turtleVid.loop = true;

    // Force reload of metadata if needed
    turtleVid.loop = false;
    turtleVid.pause();
    turtleVid.currentTime = 0;
    turtleVid.load();

    // Wait a tick so the browser applies currentTime/load changes
    await new Promise(r => requestAnimationFrame(() => r()));

    const p = turtleVid.play();
    if (p && typeof p.then === "function") await p;

  } catch (e) {
    console.warn("Turtle video play failed:", e);
    setTxVisual(false, "NO PLAY");
  }
}

function stopTurtle() {
  try {
    if (!turtleVid) return;
    turtleVid.loop = false;
    turtleVid.pause();
    turtleVid.currentTime = 0;
  } catch (_) {}
}

/** =========================
 *  SAFE DOM HELPERS
 *  ========================= */
const outputEl = document.getElementById('output');

function setStatus(text, cls = "status") {
  outputEl.innerHTML = "";
  const s = document.createElement("strong");
  s.className = cls;
  s.textContent = text;
  outputEl.appendChild(s);
}

function appendLine(label, value) {
  const div = document.createElement("div");
  const b = document.createElement("strong");
  b.textContent = label + " ";
  div.appendChild(b);
  div.appendChild(document.createTextNode(value));
  outputEl.appendChild(div);
}

/** =========================
 *  AUDIO ENGINE (live beeps)
 *  ========================= */
const MorseTiming = {
  unitMs: 60,
  freqHz: 700,
  gain: 0.4,
};

window.morseAudio = {
  audioCtx: null,
  gainNode: null,
  playing: false,
  paused: true,
  endTimer: null,
};

async function ensureAudio() {
  const st = window.morseAudio;
  if (!st.audioCtx || st.audioCtx.state === "closed") {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = ctx.createGain();
    gainNode.gain.value = MorseTiming.gain;
    gainNode.connect(ctx.destination);
    st.audioCtx = ctx;
    st.gainNode = gainNode;
    st.playing = false;
    st.paused = true;
  }
  if (st.audioCtx.state === "suspended") {
    await st.audioCtx.resume();
  }
}

function resetPlaybackUI() {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  if (pp) {
    pp.textContent = "Play Morse Sound";
    pp.classList.remove("paused");
  }
  if (stopBtn) stopBtn.disabled = true;
}

function stopMorsePlayback() {
  const st = window.morseAudio;
  if (st.endTimer) {
    clearTimeout(st.endTimer);
    st.endTimer = null;
  }
  if (st.audioCtx && st.audioCtx.state !== "closed") {
    st.audioCtx.close();
  }
  st.audioCtx = null;
  st.gainNode = null;
  st.playing = false;
  st.paused = true;
  resetPlaybackUI();
  setTxVisual(false, "IDLE");
}

async function playMorse(morseStr) {
  if (!morseStr) throw new Error("No Morse to play");

  stopMorsePlayback();
  await ensureAudio();

  const st = window.morseAudio;
  const ctx = st.audioCtx;
  const gainNode = st.gainNode;

  const unit = MorseTiming.unitMs;
  const dotMs = unit;
  const dashMs = unit * 3;
  const elemGapMs = unit;
  const letterGapMs = unit * 3;
  const wordGapMs = unit * 7;

  const playBeep = (startTimeSec, durationSec) => {
    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(MorseTiming.freqHz, startTimeSec);
    osc.connect(gainNode);
    osc.start(startTimeSec);
    osc.stop(startTimeSec + durationSec);
  };

  let t = ctx.currentTime + 0.08;

  for (const sym of morseStr) {
    if (sym === ".") {
      playBeep(t, dotMs / 1000);
      t += (dotMs + elemGapMs) / 1000;
    } else if (sym === "-") {
      playBeep(t, dashMs / 1000);
      t += (dashMs + elemGapMs) / 1000;
    } else if (sym === " ") {
      t += (letterGapMs) / 1000;
    } else if (sym === "/") {
      t += (wordGapMs) / 1000;
    }
  }

  st.playing = true;
  st.paused = false;

  setTxVisual(true, "BEEPING");

  const totalMs = Math.max(0, (t - ctx.currentTime) * 1000);
  st.endTimer = setTimeout(() => {
    st.playing = false;
    st.paused = true;
    resetPlaybackUI();
    setTxVisual(false, "READY");
  }, totalMs + 200);
}

async function toggleMorsePlayback(morseStr) {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  const st = window.morseAudio;

  if (!st.playing) {
    await playMorse(morseStr);
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    stopBtn.disabled = false;
    return;
  }

  if (!st.paused) {
    await st.audioCtx.suspend();
    st.paused = true;
    pp.textContent = "Resume Playback";
    pp.classList.remove("paused");
    setTxVisual(true, "PAUSED");
  } else {
    await st.audioCtx.resume();
    st.paused = false;
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    setTxVisual(true, "BEEPING");
  }
}

/** =========================
 *  WAV export (downloadable)
 *  ========================= */
function buildMorseTimelineMs(morseStr, unitMs) {
  const dot = unitMs;
  const dash = unitMs * 3;
  const elemGap = unitMs;       // after dot/dash
  const letterGap = unitMs * 3; // for spaces
  const wordGap = unitMs * 7;   // for "/"
  const timeline = [];
  for (const sym of morseStr) {
    if (sym === ".") {
      timeline.push({ tone: true, ms: dot });
      timeline.push({ tone: false, ms: elemGap });
    } else if (sym === "-") {
      timeline.push({ tone: true, ms: dash });
      timeline.push({ tone: false, ms: elemGap });
    } else if (sym === " ") {
      timeline.push({ tone: false, ms: letterGap });
    } else if (sym === "/") {
      timeline.push({ tone: false, ms: wordGap });
    }
  }
  while (timeline.length && timeline[timeline.length - 1].tone === false) timeline.pop();
  return timeline;
}

function floatTo16BitPCM(view, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
  }
}

function writeString(view, offset, str) {
  for (let i = 0; i < str.length; i++) {
    view.setUint8(offset + i, str.charCodeAt(i));
  }
}

function encodeWAV(samples, sampleRate) {
  const buffer = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + samples.length * 2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);      // PCM
  view.setUint16(20, 1, true);       // format
  view.setUint16(22, 1, true);       // mono
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true); // byte rate
  view.setUint16(32, 2, true);       // block align
  view.setUint16(34, 16, true);      // bits
  writeString(view, 36, 'data');
  view.setUint32(40, samples.length * 2, true);

  floatTo16BitPCM(view, 44, samples);
  return new Blob([view], { type: 'audio/wav' });
}

function synthMorseWavBlob(morseStr, opts = {}) {
  const sampleRate = opts.sampleRate || 44100;
  const freq = opts.freqHz || MorseTiming.freqHz;
  const unit = opts.unitMs || MorseTiming.unitMs;
  const volume = (typeof opts.volume === "number") ? opts.volume : 0.35;

  const timeline = buildMorseTimelineMs(morseStr, unit);
  const totalMs = timeline.reduce((a, x) => a + x.ms, 0);
  const totalSamples = Math.ceil(totalMs / 1000 * sampleRate);
  const samples = new Float32Array(totalSamples);

  let idx = 0;
  let phase = 0;
  const phaseInc = 2 * Math.PI * freq / sampleRate;
  const fadeMs = Math.min(6, unit * 0.2);
  const fadeSamples = Math.max(1, Math.floor(fadeMs / 1000 * sampleRate));

  const writeSegment = (tone, ms) => {
    const n = Math.floor(ms / 1000 * sampleRate);
    for (let i = 0; i < n && idx < samples.length; i++) {
      let v = 0;
      if (tone) {
        let amp = volume;
        if (i < fadeSamples) amp *= (i / fadeSamples);
        if (n - i - 1 < fadeSamples) amp *= ((n - i - 1) / fadeSamples);
        v = Math.sin(phase) * amp;
        phase += phaseInc;
        if (phase > 2*Math.PI) phase -= 2*Math.PI;
      }
      samples[idx++] = v;
    }
  };

  for (const seg of timeline) writeSegment(seg.tone, seg.ms);

  return encodeWAV(samples, sampleRate);
}

/** =========================
 *  UI: TRANSMIT / CLEAR / DECRYPT
 *  ========================= */
function clearAll() {
  stopMorsePlayback();
  stopTurtle();
  setTxVisual(false, "IDLE");
  setStatus("Ready...");
}

async function runDadMode() {
  const msg = document.getElementById('message').value.trim();
  const pw  = document.getElementById('password').value;

  if (!msg) { setStatus("Enter message", "error"); return; }
  if (!pw || pw.length < 8) { setStatus("Longer password recommended (8+)", "error"); return; }

  setTxVisual(true, "ENCRYPT");
  setStatus("Encrypting (AES-256-GCM)...", "status");

  // start turtle video on transmit click
  playTurtleOnce();

  try {
    const { hex } = await aesGcmEncrypt(msg, pw);
    const morse = toMorseHex(hex);

    outputEl.innerHTML = "";

    appendLine("Encrypted hex (shortened):", `${hex.slice(0,80)}... (${hex.length} chars)`);
    const hr = document.createElement("div");
    hr.className = "hr";
    outputEl.appendChild(hr);

    const morseDiv = document.createElement("div");
    morseDiv.id = "morseOutput";

    const morseTitle = document.createElement("strong");
    morseTitle.textContent = "Morse to transmit:";
    morseDiv.appendChild(morseTitle);
    morseDiv.appendChild(document.createElement("br"));

    const morseText = document.createElement("div");
    morseText.textContent = morse;
    morseDiv.appendChild(morseText);
    outputEl.appendChild(morseDiv);

    const btnRow = document.createElement("div");
    btnRow.className = "audio-row";

    const copyBtn = document.createElement("button");
    copyBtn.className = "copy-btn";
    copyBtn.textContent = "Copy Morse";
    copyBtn.addEventListener("click", async () => {
      await navigator.clipboard.writeText(morse);
      alert("Copied!");
    });

    const playPauseBtn = document.createElement("button");
    playPauseBtn.id = "playPauseBtn";
    playPauseBtn.textContent = "Play Morse Sound";
    playPauseBtn.addEventListener("click", () => {
      toggleMorsePlayback(morse).catch(err => alert("Audio error: " + err.message));
    });

    const stopBtn = document.createElement("button");
    stopBtn.id = "stopBtn";
    stopBtn.textContent = "Stop";
    stopBtn.disabled = true;
    stopBtn.addEventListener("click", stopMorsePlayback);

    const wavBtn = document.createElement("button");
    wavBtn.textContent = "Download Morse WAV";
    wavBtn.addEventListener("click", () => {
      try {
        const blob = synthMorseWavBlob(morse, { unitMs: MorseTiming.unitMs, freqHz: MorseTiming.freqHz });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `morse_${new Date().toISOString().replace(/[:.]/g,'-')}.wav`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      } catch (e) {
        alert("Could not generate WAV: " + (e?.message || String(e)));
      }
    });

    btnRow.appendChild(copyBtn);
    btnRow.appendChild(playPauseBtn);
    btnRow.appendChild(stopBtn);
    btnRow.appendChild(wavBtn);

    outputEl.appendChild(btnRow);

    setTxVisual(false, "READY");

  } catch (e) {
    setTxVisual(false, "IDLE");
    setStatus("Error: " + (e?.message || String(e)), "error");
  }
}

async function decryptDadMode() {
  const morse = document.getElementById('morseInput').value.trim();
  const pw = document.getElementById('decryptPassword').value;

  if (!morse) { alert("Paste Morse first"); return; }
  if (!pw) { alert("Enter decryption password"); return; }

  try {
    const { hex, invalid } = morseToHex(morse);
    if (invalid || hex.includes('?')) throw new Error("Invalid Morse – check copy/paste or typos");

    const plaintext = await aesGcmDecrypt(hex, pw);

    alert(`Success!\n\nOriginal message:\n${plaintext}`);

    const br = document.createElement("br");
    outputEl.appendChild(br);

    const safe = document.createElement("div");
    safe.className = "status";
    safe.style.color = "#88ffcc";
    safe.textContent = `Decrypted: ${plaintext}`;
    outputEl.appendChild(safe);

  } catch (err) {
    alert(`Failed: ${err.message}\n\nLikely causes:\n- Wrong password\n- Incomplete/invalid Morse\n- Typos in Morse`);
  }
}

/** =========================
 *  Uploaded WAV playback
 *  ========================= */
const audioUpload = document.getElementById("audioUpload");
const uploadedAudio = document.getElementById("uploadedAudio");
const audioUploadName = document.getElementById("audioUploadName");
const playUploadedBtn = document.getElementById("playUploadedBtn");
const stopUploadedBtn = document.getElementById("stopUploadedBtn");

audioUpload.addEventListener("change", () => {
  const file = audioUpload.files && audioUpload.files[0];
  if (!file) {
    audioUploadName.textContent = "No audio loaded";
    uploadedAudio.style.display = "none";
    playUploadedBtn.disabled = true;
    stopUploadedBtn.disabled = true;
    return;
  }
  audioUploadName.textContent = file.name;
  const url = URL.createObjectURL(file);
  uploadedAudio.src = url;
  uploadedAudio.style.display = "block";
  playUploadedBtn.disabled = false;
  stopUploadedBtn.disabled = false;
});

playUploadedBtn.addEventListener("click", () => {
  uploadedAudio.play().catch(() => {});
});

stopUploadedBtn.addEventListener("click", () => {
  uploadedAudio.pause();
  uploadedAudio.currentTime = 0;
});

/** =========================
 *  Wire up controls
 *  ========================= */
document.getElementById("txBtn").addEventListener("click", () => runDadMode());
document.getElementById("clearBtn").addEventListener("click", () => clearAll());
document.getElementById("decBtn").addEventListener("click", () => decryptDadMode());

document.getElementById("showPw").addEventListener("change", (e) => {
  document.getElementById("password").type = e.target.checked ? "text" : "password";
});
document.getElementById("showDecPw").addEventListener("change", (e) => {
  document.getElementById("decryptPassword").type = e.target.checked ? "text" : "password";
});

// If the mp4 is missing, show a helpful badge state
turtleVid?.addEventListener("error", () => {
  setTxVisual(false, "VIDEO?");
});

setStatus("Ready...");
setTxVisual(false, "IDLE");
</script>

</body>
</html>
