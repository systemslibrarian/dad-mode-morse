<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Encrypted Morse Messenger – AES + Sound</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0a0a0a;
      color: #00ff88;
      padding: 30px;
      max-width: 1000px;
      margin: auto;
      line-height: 1.6;
    }
    h1 { text-align: center; margin-bottom: 10px; }
    .subtitle { text-align: center; color: #88ffcc; margin-bottom: 30px; }
    .container { background: #111; padding: 25px; border-radius: 12px; border: 1px solid #00ff88; }
    label { display: block; margin: 15px 0 5px; font-weight: bold; }

    input[type="text"], input[type="password"], textarea {
      width: 100%;
      padding: 12px;
      background: #1a1a1a;
      color: #00ff88;
      border: 1px solid #00aa66;
      border-radius: 6px;
      font-family: monospace;
      font-size: 16px;
      box-sizing: border-box;
    }

    .password-row { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 15px 0; }
    .row { display:flex; gap:10px; flex-wrap: wrap; }

    button {
      padding: 12px 24px;
      background: #00ff88;
      color: black;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      margin: 10px 5px 10px 0;
    }
    button:hover { background: #33ffaa; }
    button.paused { background: #ffaa00; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* ===== Turtle transmitter visual ===== */
    .tx-visual {
      margin: 18px 0 8px;
      display: flex;
      align-items: center;
      gap: 14px;
    }

    #turtleImg {
      width: 120px;
      height: auto;
      border-radius: 14px;
      box-shadow: 0 0 0 rgba(0,255,136,0);
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
      background: #000; /* helps if image has transparency */
    }

    .tx-badge {
      font-family: monospace;
      font-weight: bold;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #00aa66;
      color: #88ffcc;
      background: #0b140b;
    }

    .tx-on #turtleImg {
      animation: txPulse 0.9s infinite ease-in-out;
      filter: brightness(1.15) saturate(1.2);
      box-shadow: 0 0 18px rgba(0,255,136,0.25);
    }

    .tx-on .tx-badge {
      color: #00ff88;
      border-color: #00ff88;
      background: #041a10;
    }

    @keyframes txPulse {
      0%, 100% { transform: scale(1.00); }
      50%      { transform: scale(1.06); }
    }
    /* ===== end turtle visual ===== */

    #output {
      background: #000;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #004d33;
      min-height: 220px;
      white-space: pre-wrap;
      font-family: monospace;
      margin-top: 20px;
      overflow-y: auto;
      max-height: 500px;
    }

    #morseOutput { margin: 15px 0; font-size: 18px; word-break: break-word; color: #ccffdd; }
    .copy-btn { font-size: 14px; padding: 8px 16px; }
    .status { color: #88ffcc; font-weight: bold; }
    .error { color: #ff6666; font-weight: bold; }

    .instructions { background: #1a2a1a; padding: 12px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #00ff88; }
    .decrypt-section {
      margin-top: 60px;
      padding: 30px 20px;
      background: #0d1a0d;
      border-radius: 10px;
      border: 1px solid #006633;
    }
    .mini { font-size: 0.95em; color:#88ffcc; }
    .hr { height: 1px; background:#0a3; opacity: 0.4; margin: 14px 0; }
  </style>
</head>
<body>

<h1>Encrypted Morse Messenger</h1>
<p class="subtitle">Encrypt → Morse code → play beeps (pause/resume/stop) → decrypt</p>

<div class="container">
  <div class="instructions">
    <strong>How to use:</strong><br>
    1. Enter message + password.<br>
    2. Click <strong>Transmit</strong> → Morse generated.<br>
    3. Copy Morse or play audio beeps (pause/resume/stop).<br>
    4. Paste Morse in the bottom section + same password → decrypt.<br><br>
    <em>Security:</em> AES-256-GCM with random salt/IV + authentication (PBKDF2-SHA256).
  </div>

  <label for="message">Message:</label>
  <textarea id="message" rows="3" placeholder="Your secret message..."></textarea>

  <label for="password">Password (for encryption):</label>
  <div class="password-row">
    <input type="password" id="password" placeholder="Strong password (don’t reuse)" />
    <label class="checkbox-row" style="margin:0;">
      <input type="checkbox" id="showPw" />
      Show
    </label>
  </div>

  <div class="row" style="margin: 18px 0;">
    <button id="txBtn">Transmit</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- Turtle transmitter visual -->
  <div class="tx-visual" id="txVisual">
    <img id="turtleImg" src="turtle.png" alt="Turtle transmitting Morse code" />
    <div id="txBadge" class="tx-badge" aria-live="polite">IDLE</div>
  </div>

  <div id="output"></div>

  <div class="decrypt-section">
    <h3>Decrypt a received message</h3>
    <p class="mini">Enter the same password used to encrypt the message.</p>

    <label for="decryptPassword">Password for decryption:</label>
    <div class="password-row">
      <input type="password" id="decryptPassword" placeholder="Re-enter the same password here" />
      <label class="checkbox-row" style="margin:0;">
        <input type="checkbox" id="showDecPw" />
        Show
      </label>
    </div>

    <label for="morseInput">Paste received Morse code here:</label>
    <textarea id="morseInput" rows="5" placeholder="Paste the full Morse string here..."></textarea>

    <div style="margin-top: 20px;">
      <button id="decBtn">Decrypt</button>
    </div>
  </div>
</div>

<script>
/** =========================
 *  MORSE <-> HEX
 *  ========================= */
const hexMorseDict = {
  '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....',
  '6':'-....','7':'--...','8':'---..','9':'----.','A':'.-','B':'-...',
  'C':'-.-.','D':'-..','E':'.','F':'..-.'
};
const reverseHexMorse = Object.fromEntries(Object.entries(hexMorseDict).map(([k,v])=>[v,k]));

function toMorseHex(hex) {
  return hex.toUpperCase().split('')
    .map(c => hexMorseDict[c] || '')
    .filter(Boolean)
    .join(' ');
}

function morseToHex(morse) {
  const groups = morse.trim().split(/\s+/).filter(Boolean);
  let hex = '';
  let invalid = false;
  for (const g of groups) {
    const ch = reverseHexMorse[g];
    if (!ch) { invalid = true; hex += '?'; }
    else hex += ch;
  }
  return { hex: hex.toLowerCase(), invalid };
}

/** =========================
 *  AES-GCM (PBKDF2)
 *  ========================= */
async function aesGcmEncrypt(plaintext, password) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["encrypt"]
  );

  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(plaintext));

  const combined = new Uint8Array(salt.length + iv.length + ct.byteLength);
  combined.set(salt,0);
  combined.set(iv, salt.length);
  combined.set(new Uint8Array(ct), salt.length + iv.length);

  const hex = Array.from(combined).map(b=>b.toString(16).padStart(2,'0')).join('');
  return { hex };
}

async function aesGcmDecrypt(hex, password) {
  if (!/^[0-9a-f]+$/i.test(hex) || hex.length < (16+12+1)*2) {
    throw new Error("Invalid hex payload length/content");
  }

  const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b=>parseInt(b,16)));
  const salt = bytes.slice(0,16);
  const iv   = bytes.slice(16,28);
  const data = bytes.slice(28);

  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), "PBKDF2", false, ["deriveBits","deriveKey"]
  );

  const key = await crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:150000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false, ["decrypt"]
  );

  const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
  return new TextDecoder().decode(decrypted);
}

/** =========================
 *  TURTLE TRANSMIT VISUAL
 *  ========================= */
function setTxVisual(on, label) {
  const container = document.getElementById("txVisual");
  const badge = document.getElementById("txBadge");
  if (!container || !badge) return;

  if (on) container.classList.add("tx-on");
  else container.classList.remove("tx-on");

  badge.textContent = label || (on ? "TRANSMITTING" : "IDLE");
}

/** =========================
 *  SAFE DOM HELPERS
 *  ========================= */
const outputEl = document.getElementById('output');

function setStatus(text, cls = "status") {
  outputEl.innerHTML = "";
  const s = document.createElement("strong");
  s.className = cls;
  s.textContent = text;
  outputEl.appendChild(s);
}

function appendLine(label, value) {
  const div = document.createElement("div");
  const b = document.createElement("strong");
  b.textContent = label + " ";
  div.appendChild(b);
  div.appendChild(document.createTextNode(value));
  outputEl.appendChild(div);
}

/** =========================
 *  AUDIO ENGINE
 *  ========================= */
const MorseTiming = {
  unitMs: 60,
  freqHz: 700,
  gain: 0.4,
};

window.morseAudio = {
  audioCtx: null,
  gainNode: null,
  playing: false,
  paused: true,
  endTimer: null,
};

async function ensureAudio() {
  const st = window.morseAudio;
  if (!st.audioCtx || st.audioCtx.state === "closed") {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = ctx.createGain();
    gainNode.gain.value = MorseTiming.gain;
    gainNode.connect(ctx.destination);
    st.audioCtx = ctx;
    st.gainNode = gainNode;
    st.playing = false;
    st.paused = true;
  }
  if (st.audioCtx.state === "suspended") {
    await st.audioCtx.resume();
  }
}

function resetPlaybackUI() {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  if (pp) {
    pp.textContent = "Play Morse Sound";
    pp.classList.remove("paused");
  }
  if (stopBtn) stopBtn.disabled = true;
}

function stopMorsePlayback() {
  const st = window.morseAudio;
  if (st.endTimer) {
    clearTimeout(st.endTimer);
    st.endTimer = null;
  }
  if (st.audioCtx && st.audioCtx.state !== "closed") {
    st.audioCtx.close();
  }
  st.audioCtx = null;
  st.gainNode = null;
  st.playing = false;
  st.paused = true;
  resetPlaybackUI();
  setTxVisual(false, "IDLE");
}

async function playMorse(morseStr) {
  if (!morseStr) throw new Error("No Morse to play");

  stopMorsePlayback();
  await ensureAudio();

  const st = window.morseAudio;
  const ctx = st.audioCtx;
  const gainNode = st.gainNode;

  const unit = MorseTiming.unitMs;
  const dotMs = unit;
  const dashMs = unit * 3;
  const elemGapMs = unit;
  const letterGapMs = unit * 3;
  const wordGapMs = unit * 7;

  const playBeep = (startTimeSec, durationSec) => {
    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(MorseTiming.freqHz, startTimeSec);
    osc.connect(gainNode);
    osc.start(startTimeSec);
    osc.stop(startTimeSec + durationSec);
  };

  let t = ctx.currentTime + 0.08;

  for (const sym of morseStr) {
    if (sym === ".") {
      playBeep(t, dotMs / 1000);
      t += (dotMs + elemGapMs) / 1000;
    } else if (sym === "-") {
      playBeep(t, dashMs / 1000);
      t += (dashMs + elemGapMs) / 1000;
    } else if (sym === " ") {
      t += (letterGapMs) / 1000;
    } else if (sym === "/") {
      t += (wordGapMs) / 1000;
    }
  }

  st.playing = true;
  st.paused = false;

  setTxVisual(true, "BEEPING");

  const totalMs = Math.max(0, (t - ctx.currentTime) * 1000);
  st.endTimer = setTimeout(() => {
    st.playing = false;
    st.paused = true;
    resetPlaybackUI();
    setTxVisual(false, "READY");
  }, totalMs + 200);
}

async function toggleMorsePlayback(morseStr) {
  const pp = document.getElementById("playPauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  const st = window.morseAudio;

  if (!st.playing) {
    await playMorse(morseStr);
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    stopBtn.disabled = false;
    return;
  }

  if (!st.paused) {
    await st.audioCtx.suspend();
    st.paused = true;
    pp.textContent = "Resume Playback";
    pp.classList.remove("paused");
    setTxVisual(true, "PAUSED");
  } else {
    await st.audioCtx.resume();
    st.paused = false;
    pp.textContent = "Pause Playback";
    pp.classList.add("paused");
    setTxVisual(true, "BEEPING");
  }
}

/** =========================
 *  UI: TRANSMIT / CLEAR / DECRYPT
 *  ========================= */
function clearAll() {
  stopMorsePlayback();
  setTxVisual(false, "IDLE");
  setStatus("Ready...");
}

async function runDadMode() {
  const msg = document.getElementById('message').value.trim();
  const pw  = document.getElementById('password').value;

  if (!msg) { setStatus("Enter message", "error"); return; }
  if (!pw || pw.length < 8) { setStatus("Longer password recommended (8+)", "error"); return; }

  setTxVisual(true, "ENCRYPTING");
  setStatus("Encrypting (AES-256-GCM)...", "status");

  try {
    const { hex } = await aesGcmEncrypt(msg, pw);
    const morse = toMorseHex(hex);

    outputEl.innerHTML = "";
    appendLine("Encrypted hex (shortened):", `${hex.slice(0,80)}... (${hex.length} chars)`);

    const hr = document.createElement("div");
    hr.className = "hr";
    outputEl.appendChild(hr);

    const morseDiv = document.createElement("div");
    morseDiv.id = "morseOutput";

    const morseTitle = document.createElement("strong");
    morseTitle.textContent = "Morse to transmit:";
    morseDiv.appendChild(morseTitle);
    morseDiv.appendChild(document.createElement("br"));

    const morseText = document.createElement("div");
    morseText.textContent = morse;
    morseDiv.appendChild(morseText);
    outputEl.appendChild(morseDiv);

    const copyBtn = document.createElement("button");
    copyBtn.className = "copy-btn";
    copyBtn.textContent = "Copy Morse";
    copyBtn.addEventListener("click", async () => {
      await navigator.clipboard.writeText(morse);
      alert("Copied!");
    });
    outputEl.appendChild(copyBtn);

    const playPauseBtn = document.createElement("button");
    playPauseBtn.id = "playPauseBtn";
    playPauseBtn.textContent = "Play Morse Sound";
    playPauseBtn.addEventListener("click", () => {
      toggleMorsePlayback(morse).catch(err => alert("Audio error: " + err.message));
    });
    outputEl.appendChild(playPauseBtn);

    const stopBtn = document.createElement("button");
    stopBtn.id = "stopBtn";
    stopBtn.textContent = "Stop";
    stopBtn.disabled = true;
    stopBtn.addEventListener("click", stopMorsePlayback);
    outputEl.appendChild(stopBtn);

    setTxVisual(false, "READY");

  } catch (e) {
    setTxVisual(false, "IDLE");
    setStatus("Error: " + (e?.message || String(e)), "error");
  }
}

async function decryptDadMode() {
  const morse = document.getElementById('morseInput').value.trim();
  const pw = document.getElementById('decryptPassword').value;

  if (!morse) { alert("Paste Morse first"); return; }
  if (!pw) { alert("Enter decryption password"); return; }

  try {
    const { hex, invalid } = morseToHex(morse);
    if (invalid || hex.includes('?')) throw new Error("Invalid Morse – check copy/paste or typos");

    const plaintext = await aesGcmDecrypt(hex, pw);

    alert(`Success!\n\nOriginal message:\n${plaintext}`);

    const br = document.createElement("br");
    outputEl.appendChild(br);

    const safe = document.createElement("div");
    safe.className = "status";
    safe.style.color = "#88ffcc";
    safe.textContent = `Decrypted: ${plaintext}`;
    outputEl.appendChild(safe);

  } catch (err) {
    alert(`Failed: ${err.message}\n\nLikely causes:\n- Wrong password\n- Incomplete/invalid Morse\n- Typos in Morse`);
  }
}

/** =========================
 *  Wire up controls
 *  ========================= */
document.getElementById("txBtn").addEventListener("click", () => runDadMode());
document.getElementById("clearBtn").addEventListener("click", () => clearAll());
document.getElementById("decBtn").addEventListener("click", () => decryptDadMode());

document.getElementById("showPw").addEventListener("change", (e) => {
  document.getElementById("password").type = e.target.checked ? "text" : "password";
});
document.getElementById("showDecPw").addEventListener("change", (e) => {
  document.getElementById("decryptPassword").type = e.target.checked ? "text" : "password";
});

setStatus("Ready...");
setTxVisual(false, "IDLE");
</script>

</body>
</html>
